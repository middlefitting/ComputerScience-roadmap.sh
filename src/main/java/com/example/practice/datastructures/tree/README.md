## 개요

트리는 계층적으로 데이터를 저장하는 특별한 자료구조입니다. 이는 엣지로 연결되는 중심 노드, 구조 노드, 서브 노드들로 구성됩니다.
다른 표현으로는 루트, 브랜치, 리프로 연결된 자료구조입니다.

트리는 자료를 순차적으로 저장하지 않습니다. 따라서 비선형 자료구조라고 말합니다. 대신 여러 수준에서 배열된 계층 구조라고 할 수 있습니다.

## 트리의 구성 요소

- Root: 트리의 최상단 노드를 의미합니다.
- Child Node: 특정 노드 하위의 노드들을 의미합니다. 간선으로 연결됩니다.
- Parent Node: 특정 노드 상위의 노드를 의ㅁ합니다. 간선으로 연결됩니다.
- Leaf Node: child node가 존재하지 않는 노드들을 의미합니다.
- Ancestor of a Node: 특정 노드의 상위 모든 노드들을 의미합니다.(조상 노드)
- Descendant: 특정 노드 하위의 모든 노드들을 의미합니다.(자손)
- Sibling: 같은 parent node를 가진 노드들을 의미합니다. (형제 노드)
- Level of a node: Root까지의 간선 수를 의미합니다. Root의 레벨은 0입니다.
- Internal node: 한개 이상의 자식을 보유한 노드를 의미합니다.
- Neighbour of a Node: 특정 노드의 Parent 혹은 Child 노드들을 말합니다.
- Subtree: 특정 노드를 루트로 가지는 트리를 의미합니다.

## 트리 자료구조의 노드 표현

트리는 노드의 컬렉션을 사용하는 것으로 표현할 수 있습니다. 그리고 노드는 다양한 언어의 클래스와 구조체로 표현될 수 있습니다.

~~~java
class Node<T> {
	T data;
	Node firstChild;
	Node secondChild;
	Node thirdChild;
	// ...
	Node nthChild;
}
~~~

## 트리의 활용

### 계층적 자료구조

트리는 데이터 구조를 계층적으로 표현하고 싶을 때 활용할 수 있습니다.
대표적으로는 우리가 사용하는 컴퓨터의 파일 시스템입니다.

### 검색

BST와 같이 순서가 존재하는 트리는 인덱스를 활용한 자료의 접근이 가능합니다. 링크드리스트보다는 빠르고 배열보다는 느린 특징이 있습니다.

### 수정 및 삭제

수정 및 삭제에서는 배열보다는 빠르고 링크드리스트(순서가 존재하지 않는)보다는 느린 특징이 있습니다.

### 제한 없음

링크드리스트처럼 트리는 노드간 포인터를 통해 연결되기 떄문에 노드 수의 제한이 없습니다.

## 자식수에 따른 트리의 구분

- Binary Tree: 두개의 자식을 가지는 트리를 의미합니다.
- Ternary Tree: left, mid, right의 세개의 자식을 가지는 트리를 의미합니다.
- N-ary Tree or Generic Tree: 그 외의 자식수를 가지는 트리를 의미합니다.

## 트리의 속성

- Number of edges: 간선 수를 의미하며 노드보다 1개 적은 수를 가집니다.
- Depth of a Node: 루트까지의 간선 수를 의미합니다.
- Height of the Tree: 루트에서 리프노드까지의 최대 Depth를 의미합니다.
- Degree of a Node: 차수, 해당 노드에 연결된 자식의 수를 의미합니다.

## 트리 데이터 구조의 활용

- File System: Linux
- Data Compression: Huffman coding
- Compiler Design: Syntax tree
- Database Indexing: BTree

## 트리의 장단점

### 장점

- 탐색: 균형 트리의 경우 O(logN)
- 정보의 구성: 계층적 정보 구성을 대량의 정보 구성 가능

### 단점

- 불균형 트리는 검색의 비효율성을 가지게 됩니다.
- 다른 자료구조보다 더 많은 메모리를 필요로 합니다.
- 복잡성이 존재하여 러닝커브를 필요로 합니다.

## 트리의 순회

대표적인 3개의 트리 Traversal을 소개드리겠습니다. 루트를 기준으로 생각하시면 이해가 편합니다.

### PreOrder

        1
       / \
      2   3

### InOrder

        2
       / \
      1   3

### PostOrder

        3
       / \
      1   2
